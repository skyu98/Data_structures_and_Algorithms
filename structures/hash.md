# 学习数据结构与算法的一些笔记--*散列表（概念和特点）*
## 一、散列表
1.散列表来源于数组，它借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照下标随机访问元素的特性。这样其访问操作时间复杂度为O(1)。
2.需要存储在散列表中的数据我们称为键，将键转化为数组下标的方法称为散列函数，散列函数的计算结果称为散列值。
3.将数据存储在散列值对应的数组下标位置。

## 二、设计散列函数的基本要求
* 1.散列函数计算得到的散列值是一个非负整数。
* 2.若key1=key2，则hash(key1)=hash(key2)
* 3.若key≠key2，则hash(key1)≠hash(key2)

正是由于第3点要求，所以产生了几乎无法避免的散列冲突问题。

## 三、散列冲突
常用的散列冲突解决方法有2类：**开放寻址法（open addressing）**和**链表法（chaining）.**
### 1.开放寻址法
核心思想：如果出现散列冲突，就重新探测一个空闲位置，将其插入。
#### (1)线性探测法（Linear Probing）：
* 插入数据：当我们往散列表中插入数据时，如果某个数据经过散列函数之后，存储的位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。

* 查找数据：我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素是否相等，若相等，则说明就是我们要查找的元素；否则，就顺序往后依次查找。如果遍历到数组的空闲位置还未找到，就说明要查找的元素并没有在散列表中。
* 删除数据：为了不让查找算法失效，可以将删除的元素特殊标记为deleted，当线性探测查找的时候，遇到标记为deleted的空间，并不是停下来，而是继续往下探测。
结论：**最坏时间复杂度为O(n)**
#### (2)二次探测（Quadratic probing）：
线性探测每次探测的步长为1，即在数组中一个一个探测，而二次探测的步长变为原来的平方。
#### (3)双重散列（Double hashing）：
使用一组散列函数，直到找到空闲位置为止。

### 2.链表法（更常用）
* 插入数据：当插入的时候，我们需要通过散列函数计算出对应的散列槽位，将其插入到对应的链表中即可，所以插入的时间复杂度为O(1)。

* 查找或删除数据：当查找、删除一个元素时，通过散列函数计算对应的槽，然后遍历链表查找或删除。对于散列比较均匀的散列函数，链表的节点个数k=n/m，其中n表示散列表中数据的个数，m表示散列表中槽的个数，所以是时间复杂度为O(k)。

### 3.装载因子：
用“装载因子”来表示空位多少，公式：```散列表装载因子=填入表中的个数/散列表的长度```。
装载因子越大，说明空闲位置越少，冲突越多，插入数据会多次寻址或者链表很长，散列表的性能会下降。

* **所以当装载因子触发阈值时，则需要进行动态扩容。** 针对散列表的扩容，数据搬移操作要复杂很多。因为散列表的大小变了，数据的存储位置也可能变了，所以我们需要通过散列函数重新计算每个数据的存储位置。与数组一样，这样的插入操作**均摊复杂度为O(1)。**

* **避免低效的扩容。** 装载因子触达阈值之后，只申请新空间，并不将旧数据搬移到新散列表中。当有新数据要插入时，将新数据插入新散列表中，并且从旧的散列表中拿出一个数据放入到新散列表。经过多次插入操作之后，旧的数据就全部搬移到新散列表中了。这种实现方式，任何情况下，**插入一个数据的时间复杂度都是 O(1)。**

### 4.两种方法的对比和选择
||优点|缺点|适用场合|
|--|--|---|-|
|开放寻址法|1.利用CPU缓存加快查询速度<br>2.序列化起来比较简单 | 1.删除数据需要标记<br>2.装载因子不能太大，更浪费内存空间|**数据量比较小、装载因子小（比如ThreadLocalMap）**|
|链表法|1.内存利用率高<br>2.对大的装载因子容忍度高<br>3.有多种优化方式（红黑树代替链表）|1.存储小对象浪费内存<br>2.零散分布影响效率|**存储大对象、大数据量的散列表**|

## 四、工业级散列表举例分析
何为一个工业级的散列表？工业级的散列表应该具有哪些特性？
* 支持快速地查询、插入、删除操作；
* 内存占用合理，不能浪费过多的内存空间；
* 性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况。

如何实现这样一个散列表呢？
* 设计一个合适的散列函数；
* 定义装载因子阈值，并且设计动态扩容策略；
* 选择合适的散列冲突解决方法。

### Java 中的 HashMap的应用
#### 1.初始大小HashMap 
默认的初始大小是 16，当然这个默认值是可以设置的，如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，这样会大大提高 HashMap 的性能。

#### 2.装载因子和动态扩容
最大装载因子默认是 0.75，当 HashMap 中元素个数超过 0.75*capacity（capacity 表示散列表的容量）的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。

#### 3.散列冲突解决方法
HashMap 底层采用链表法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 HashMap 的性能。于是，为了对 HashMap 做进一步优化，当链表长度太长（默认超过 8）时，链表就转换为红黑树。可以利用红黑树快速增删改查的特点，提高 HashMap 的性能。当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。

#### 4.散列函数
散列函数的设计并不复杂，追求的是简单高效、分布均匀。

```java
int hash(Object key) { 
        int h = key.hashCode()； 
        return (h ^ (h >>> 16)) & (capicity -1);//capicity表示散列表的大小其中，hashCode() 返回的是Java对象的hash code
    }
```
可以分为两步来看：
```java
 hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
```
这一步叫**扰动函数**，为什么要右移16位再与本身异或呢？
* 首先hashCode()返回值int最高是32位，如果直接拿hashCode()返回值作为下标，大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般是很难出现碰撞的。但是一个40亿长度的数组，内存是放不下的。
* 用自己的高半区和低半区做异或，混合原始哈希码的高位和低位，关键是以此来加大低位的随机性。为后续计算index截取低位，保证低位的随机性。
* 这样设计保证了对象的hashCode的32位值只要有一位发生改变，整个hash()返回值就会改变，高位的变化会反应到低位里，保证了hash值的随机性。

```java
int index = hash(key) & (capacity - 1)
```
将hash()扰动函数计算的值和hash表当前的容量减一，做按位与运算。
$$A \% B = A \& (B - 1)，当B是2的指数时，等式成立。$$

本质上是使用了「除留余数法」，保证了index的位置分布均匀，位运算更加高效。
**这也是列表长度必须是2的指数幂的原因**。rehash时需要重新计算桶位置，如果不是2的幂，n -1转为二进制后，最低位始终是0，导致最低位为0的桶被浪费，造成更多的hash碰撞。

## 四、思考
### 1.Word文档中单词拼写检查功能是如何实现的？
字符串占用内存大小为8字节，20万单词占用内存大小不超过20MB，所以用散列表存储20万英文词典单词，然后对每个编辑进文档的单词进行查找，若未找到，则提示拼写错误。

### 2.假设我们有10万条URL访问日志，如何按照访问次数给URL排序？
字符串占用内存大小为8字节，10万条URL访问日志占用内存不会很大。通过散列表统计url访问次数，然后根据数据范围确定排序方法（桶排序OR快排），排序后取出url，则为url排序结果。

### 3.有两个字符串数组，每个数组大约有10万条字符串，如何快速找出两个数组中相同的字符串？
将A数组的字符串通过散列函数映射到散列表，散列表中的元素值为次数（或者```bool isExisted```)。然后，遍历B数组，在散列表中进行查找，如果次数>=1（或者```isExisted == True```），则该字符串就是两个数组中相同的字符串。