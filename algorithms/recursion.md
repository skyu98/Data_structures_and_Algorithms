# 学习数据结构与算法的一些笔记--*递归（主要思想和特点）*

## 一、递归需要满足的三个条件

* #### 1.一个问题的解可以分解为几个子问题的解
* #### 2.这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
* #### 3.存在递归终止条件

### 举个例子：走台阶
**如果一次只能走一步或两步，需要走完n个阶梯，一共有多少种走法？**
在有n个阶梯时，共有两种走法，即走一步到第n-1个，走两步到第n-2个。所以 n 个台阶的走法就等于先走 1 阶后，n-1 个台阶的走法 加上先走 2 阶后，n-2 个台阶的走法。用公式表示就是：
```
f(n) = f(n-1) + f(n-2)
```
**此处已满足1和2两个条件，还需要分析是否存在边界终止条件**
当还剩2个阶梯时，有两步一次走完和分两次一步走完，即f(2) = 2;还剩1个阶梯时，只有一步一次走完，即f(1) = 1。
**因此，满足三个条件；可以作为递归问题解决：**
```cpp
class solution{
public:
    int FindSteps(n)
    {
        if(n == 2) return 2;
        if(n == 1) return 1;
        return FindSteps(n-2) + FindSteps(n-1);
    }
}
```
## 二、如何实现递归？

* #### 1.递归代码编写
写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。
* #### 2.递归代码理解
对于递归代码，若试图想清楚整个递和归的过程，实际上是进入了一个思维误区。
那该如何理解递归代码呢？如果一个问题A可以分解为若干个子问题B、C、D，你可以假设子问题B、C、D已经解决。而且，你只需要思考问题A与子问题B、C、D两层之间的关系即可，不需要一层层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。
因此，理解递归代码，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。

## 三、递归常见问题及解决方案

* #### 1.警惕堆栈溢出
可以声明一个全局变量来控制递归的深度，从而避免堆栈溢出。
* #### 2.警惕重复计算
通过某种数据结构来保存已经求解过的值，比如一个hashMap，从而避免重复计算。

## 四、如何将递归改写为非递归代码

笼统的讲，所有的递归代码都可以改写为迭代循环的非递归写法。如何做？抽象出递推公式、初始值和边界条件，然后用迭代循环实现。

## 五、经典题目
### 1.目标和
给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

 

示例：
```
输入：nums: [1, 1, 1, 1, 1], S: 3
输出：5
解释：

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

一共有5种方法让最终目标和为3。
```

提示：

数组非空，且长度不会超过 20 。
初始的数组的和不会超过 1000 。
保证返回的最终结果能被 32 位整数存下。

#### 思路：从S开始，可以进行+a[1]/-a[1]两种操作；之后每一个结点都会进行相同的操作。在对a[n]进行操作后，若结果为0，则计数加一；否则直接返回。
```cpp
class Solution {
public:
    int cnt=0;
    // 考虑递归函数，需要传入数组、当前下标idx、当前S
    void solve(int idx, vector<int>& nums, int S)
    {
        // 边界条件，在操作a[n]后
        if(idx == nums.size())
        {
            // 如果S为0，则计数加一
            if(0 == S)
            {
                cnt++;   
            }
            return;
        }
        // 加和减操作
        solve(idx+1, nums, S+nums[idx]);
        solve(idx+1, nums, S-nums[idx]);
    }
    
    int findTargetSumWays(vector<int>& nums, int S) {
        if(S>1000) return 0;
        
        solve(0, nums, S);        
        return cnt;
    }
 };
```
### 2.二叉树的中序遍历
给定一个二叉树，返回它的中序 遍历。

示例:
```
输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
```
#### 思路：从根节点开始，处理左子树、记录根节点、处理右子树；边界条件为，如果节点为NULL，直接返回。
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> res;
    
    void solve(TreeNode* r){
        // 边界条件
        if(r == NULL)
        {
            return;
        }
        // 解决左子树
        solve(r->left);
        // 记录根节点值（叶节点可以看做子节点为NULL的根节点）     
        res.push_back(r->val);
        // 处理右子树
        solve(r->right);
    }
    
    vector<int> inorderTraversal(TreeNode* root) {
        solve(root);
        return res;
    }
};
```